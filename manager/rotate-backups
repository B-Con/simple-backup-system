#!/bin/bash

# By: B-Con (Brad Conte: brad AT bradconte COM)
#
# This is a script to create backups from specified folders. The folder to be
# rotated/archived should have the name structure:
#     NAME/current
# where "current" has the latest stuff to backup. Backups will be created with
# the naming structure:
#     NAME/NAME_YYYY-MM-DD_HH-MM-SS.tar.EXT


# ==============================================================================
# Constants
# ==============================================================================

SCRIPT_PATH="`dirname "$0"`"
cd "$SCRIPT_PATH"
source "../config/global.config"

DEFAULT_NUM_BACKUPS=10   # For weekly backups, this is just over two months.


# ==============================================================================
# Function definitions
# ==============================================================================

# Args: 1 = folder to backup.
# Creates the archive, owns it, and makes it read-only.
create_archive()
{
	local PROJ_NAME="$1"
	local BACKUP_SOURCE="current"

	if [ ! -d "$BACKUP_SOURCE" -a ! -f "$BACKUP_SOURCE" ]; then
		echo "Error: Backup path ${BACKUP_SOURCE} doesn't exist" >&2
		return 1
	fi

	# Don't bother backing up empty directories.
	if [ -z "`ls -A $BACKUP_SOURCE`" ]; then
		return 0
	fi

	local LATEST_BACKUP_FILE="`ls -t | grep -e "^${PROJ_NAME}" | head -n 1`"
	local NEW_BACKUP_SOURCE="${PROJ_NAME}_`date +%Y-%m-%d_%H-%M-%S`"
	local NEW_BACKUP_FILE="${NEW_BACKUP_SOURCE}.tar.gz"

	# Rename the to-archive folder to the base name of the archive file. This
	# allows the root file on extraction to be named properly and prevents
	# any backups from occuring while the archive is created, which would result
	# in a mixed state.
	mv "$BACKUP_SOURCE" "$NEW_BACKUP_SOURCE"
	tar -czf "$NEW_BACKUP_FILE" "$NEW_BACKUP_SOURCE"
	local SUCCESS=$?
	mv "$NEW_BACKUP_SOURCE" "$BACKUP_SOURCE"
	if [ $SUCCESS -ne 0 ]; then
		echo "Error: Could not create archive $NEW_BACKUP_FILE" 2>&1
		return 1
	fi

	# Make the backups read-only and owned by root. This is safest.
	chmod 444 "$NEW_BACKUP_FILE"
	chown root:root "$NEW_BACKUP_FILE"

	# Note: Don't remove the "current" contents. The backups may use optimized
	# syncing that only updates modified files. Removing it would eliminate
	# that efficiency.

	# TODO: The below doesn't work properly since the root directory in each archive is named
	# differently, so the archives are never the exact same.
	# ---
	# If the backup is an exact duplicate of the previous one, delete the older one.
	# We don't need duplicates in the archive history. Keep the new one (not the old one)
	# to indicate how new the file contents were, we probably care more about
	# exactly how new the latest archive is rather than exactly how old it is.
	if [ ! -z "$LATEST_BACKUP_FILE" -a -x `which md5sum` ]; then
		local LATEST_BACKUP_FILE="`md5sum "$LATEST_BACKUP_FILE" | cut -f 1 -d ' '`"
		local CURRENT_CHECKSUM="`md5sum "$NEW_BACKUP_FILE" | cut -f 1 -d ' '`"
		if [ "$LATEST_BACKUP_FILE" = "$CURRENT_CHECKSUM" ]; then
			rm -f "$LATEST_BACKUP_FILE"
		fi
	fi
}

# Args: 1st = prepend-name for archives, 2nd = number of archives to keep, if 2nd is
# not set or is 0 then use the default number, if it's -1 then don't prune.
prune_backups()
{
	local PROJ_NAME="$1"
	local BACKUP_LIST="`ls -tr | grep -e "^${PROJ_NAME}"`"

	# There may be nothing to prune.
	if [ -z "$BACKUP_LIST" -o $(( $2 )) -eq $(( -1 )) ]; then
		return 0
	fi

	local NUM_BACKUPS=$DEFAULT_NUM_BACKUPS
	[ $(( $2 )) -gt 0 ] && NUM_BACKUPS=$2

	# Prune archives that aren't recent enough.
	if [ $(( `echo "$BACKUP_LIST" | wc -l` )) -gt $NUM_BACKUPS ]; then
		# Use -f since archives/backups may be read-only.
		echo "$BACKUP_LIST" | head -n -$NUM_BACKUPS | xargs rm -f
	fi
}

# Args: 1 = folder to backup, 2 = number of backups to keep (optional).
rotate_and_prune()
{
	local BASE_PATH="$1"
	local PROJ_NAME="`basename "$1"`"

	# todo: remove
	echo Rotating: $1

	if [ ! -d "$BASE_PATH" ]; then
		echo "Error: Specified archive path $BASE_PATH is not a directory" >&2
		return 1
	fi
	pushd "$BASE_PATH" > /dev/null

	create_archive "$PROJ_NAME"
	prune_backups "$PROJ_NAME" $2

	popd > /dev/null
}

# ==============================================================================
# Main program
# ==============================================================================

if [ "$EUID" != "0" ]; then
	echo "Must run backup as root." >&2
	exit 1
fi

if [ ! -d "$BACKUP_ROOT_DIR" ]; then
	echo "Specified backup root path $BACKUP_ROOT_DIR is not a directory." >&2
	exit 1
fi
cd "$BACKUP_ROOT_DIR" || exit 1

# For simple testing.
#rotate_and_prune "brad-internet/MyAnimeList.net"
#rotate_and_prune "brad-desktop/test-script"

# TODO: Just auto-prune everything equally?
# All backup profiles are within a higher-level organizational folder, so
# they are 2 layers deep from the root backup folder. Folders with the folder
# "current" are assumed to be participating in this automated system. (Note
# that NOT all folders are participating.) Prune those.
for next_backup_dir in `find . -maxdepth 2 -mindepth 2 -type d`; do
	if [ -d "${next_backup_dir}/current" ]; then
		rotate_and_prune "$next_backup_dir"
	fi
done
